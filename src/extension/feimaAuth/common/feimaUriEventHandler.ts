/*---------------------------------------------------------------------------------------------
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import type { Uri, UriHandler } from 'vscode';
import { ILogger } from '../../../platform/log/common/logService.js';
import { Emitter, Event } from '../../../util/vs/base/common/event.js';

/**
 * OAuth2 callback data structure.
 */
interface ICallbackData {
	code: string;
	state: string;
}

/**
 * Callback resolver for a specific OAuth2 flow.
 */
interface IPendingCallback {
	nonce: string;
	resolve: (data: ICallbackData) => void;
	reject: (error: Error) => void;
}

/**
 * URI event handler for Feima OAuth2 callbacks.
 * Handles multiple concurrent authorization flows using nonce-based routing.
 *
 * Pattern adapted from GitHub Copilot authentication:
 * Each authorization request generates a unique nonce.
 * Multiple pending callbacks can coexist simultaneously.
 * Incoming URIs are routed to the correct callback via nonce matching.
 */
export class FeimaUriEventHandler implements UriHandler {
	private readonly _onDidReceiveCallback = new Emitter<ICallbackData>();
	readonly onDidReceiveCallback: Event<ICallbackData> = this._onDidReceiveCallback.event;

	/**
	 * Map of nonce â†’ pending callback.
	 * Allows multiple concurrent OAuth flows.
	 */
	private readonly _pendingCallbacks = new Map<string, IPendingCallback>();

	constructor(
		private readonly logger: ILogger
	) { }

	/**
	 * Handle incoming OAuth2 callback URI.
	 * Routes callback to the appropriate pending authorization request.
	 *
	 * @param uri Callback URI from feima-idp: vscode://feima.copilot/auth-callback?code=...&state=...
	 */
	handleUri(uri: Uri): void {
		this.logger.trace(`[FeimaUriEventHandler] Received callback URI: ${uri.toString()}`);

		try {
			// Parse query parameters
			const query = new URLSearchParams(uri.query);
			const code = query.get('code');
			const state = query.get('state');

			if (!code || !state) {
				this.logger.error(`[FeimaUriEventHandler] Invalid callback URI: missing code=${!!code}, state=${!!state}`);
				return;
			}

			// Extract nonce from state parameter
			// For Feima, state IS the nonce (generated by OAuth2Service)
			const nonce = state;
			if (!nonce) {
				this.logger.error(`[FeimaUriEventHandler] Invalid state parameter: missing nonce, state=${state}`);
				return;
			}

			// Find pending callback for this nonce
			const pending = this._pendingCallbacks.get(nonce);
			if (!pending) {
				this.logger.warn(`[FeimaUriEventHandler] No pending callback found for nonce=${nonce}, pendingCount=${this._pendingCallbacks.size}`);
				return;
			}

			// Remove from pending map
			this._pendingCallbacks.delete(nonce);

			this.logger.info(`[FeimaUriEventHandler] Routing callback to pending request: nonce=${nonce}, remainingPending=${this._pendingCallbacks.size}`);

			// Resolve the promise
			pending.resolve({ code, state });

			// Fire event for listeners
			this._onDidReceiveCallback.fire({ code, state });

		} catch (error) {
			this.logger.error(error instanceof Error ? error : new Error(String(error)), '[FeimaUriEventHandler] Failed to handle callback URI');
		}
	}

	/**
	 * Register a pending OAuth2 authorization request.
	 *
	 * @param nonce Unique nonce for this authorization flow
	 * @returns Promise that resolves when callback is received
	 */
	registerPendingCallback(nonce: string): Promise<ICallbackData> {
		return new Promise<ICallbackData>((resolve, reject) => {
			this._pendingCallbacks.set(nonce, { nonce, resolve, reject });
			this.logger.trace(`[FeimaUriEventHandler] Registered pending callback: nonce=${nonce}, pendingCount=${this._pendingCallbacks.size}`);

			// Timeout after 5 minutes
			setTimeout(() => {
				if (this._pendingCallbacks.has(nonce)) {
					this._pendingCallbacks.delete(nonce);
					this.logger.warn(`[FeimaUriEventHandler] Callback timeout: nonce=${nonce}, remainingPending=${this._pendingCallbacks.size}`);
					reject(new Error('OAuth2 authorization timeout after 5 minutes'));
				}
			}, 5 * 60 * 1000);
		});
	}

	/**
	 * Cancel a pending authorization request.
	 *
	 * @param nonce Unique nonce to cancel
	 */
	cancelPendingCallback(nonce: string): void {
		const pending = this._pendingCallbacks.get(nonce);
		if (pending) {
			this._pendingCallbacks.delete(nonce);
			pending.reject(new Error('OAuth2 authorization canceled'));
			this.logger.info(`[FeimaUriEventHandler] Canceled pending callback: nonce=${nonce}, remainingPending=${this._pendingCallbacks.size}`);
		}
	}

	dispose(): void {
		// Reject all pending callbacks
		for (const [nonce, pending] of this._pendingCallbacks.entries()) {
			pending.reject(new Error('FeimaUriEventHandler disposed'));
			this.logger.trace(`[FeimaUriEventHandler] Rejected pending callback on dispose: nonce=${nonce}`);
		}
		this._pendingCallbacks.clear();
		this._onDidReceiveCallback.dispose();
	}
}
